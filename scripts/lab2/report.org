#+LATEX_CLASS: general
#+OPTIONS: toc:nil date:nil title:nil

#+begin_titlepage org
#+begin_center org
\large\textbf{Федеральное государственное автономное образовательное учреждение высшего образования ``Национальный исследовательский университет ИТМО``} \\

\vspace{0.5cm}

Факультет информационных технологий и программирования \\

\vspace{0.5cm}

Направление ``Прикладная математика и информатика`` \\



\vspace{3cm}



Отчет к лабораторной работе №2 \\

\vspace{0.5cm}

\textbf{Методы многомерной оптимизации}
#+end_center




\vfill

#+begin_flushright org
\large
Выполнили студенты группы М3237 \\

\vspace{0.5cm}

Ярошевский Илья \\
Аникина Вероника \\
Крюков Александр
#+end_flushright


\vspace{3cm}

#+begin_center org
Санкт-Петербург 2021
#+end_center
#+end_titlepage



* Цели работы
1. Реализовать алгоритмы
   - Метод градиентного спуска
   - Метод наискорейшего спуска
   - Метод сопряженных градиентов
2. Проанализировать траектории методов для некоторых квадратичных функций
3. Исследовать количество итераций в зависимости от размерности пространства и числа обусловленности
* Ход работы
Во всех тестах начальное приближение --- вектор размерности
пространства из единиц, точность \varepsilon = 0.001, ограничение на
количество итераций --- 10000
** Количество итераций
*** Метод градиентного спуска
#+ATTR_LATEX: :scale 0.4
[[file:plots/gradient_descent_1.png]] Видно, что количество итераций не
зависит от размерности пространства \(n\), но линейно зависит от числа
обусловленности \(k\)
*** Метод наискорейшего спуска 
#+ATTR_LATEX: :scale 0.4
[[file:plots/steepest_gradient_1.png]] Так же как и в методе градиентного
спуска можно видеть линейную зависимость количества итераций от числа
обусловленности. Количество итераций так же не зависит от размерности
пространства.
*** Метод сопряженный градиентов
#+ATTR_LATEX: :scale 0.4
[[file:plots/conjugate_gradient_1.png]] По очевидным причинам количество
итераций для произвольной функции будет константным и равным
размерности пространства.
** Траектории
\[ f_1(x) = \frac{1}{2}\begin{pmatrix}
100 & -1 \\
-1 & 1
\end{pmatrix} x^2 + \begin{pmatrix} -10 & 0 \end{pmatrix}x\]
Все методы находят минимум функции \(f_1^* = -0.50505\) в точке \(x^* = (0.101011\ 0.1011)\)
\[ f_2(x) = \frac{1}{2}\begin{pmatrix}
3 & -1 \\
-1 & 2
\end{pmatrix} x^2 + \begin{pmatrix} -5 & 2 \end{pmatrix}x\]
Все методы находят минимум функции \(f_2^* = -4.2\) в точке \(x^* = (1.6\ -0.2)\)
\[ f_3(x) = \frac{1}{2}\begin{pmatrix}
1 & -1 \\
-1 & 2
\end{pmatrix} x^2 + \begin{pmatrix} -10 & 2 \end{pmatrix}x\]
Все методы находят минимум функции \(f_3^* = -82\) в точке \(x^* = (18\ 8)\) \\
*** Метод градиентного спуска
\-
#+CAPTION: Траектория метода на функции \(f_1\)
#+ATTR_LATEX: :scale 0.3 :options [H] :float nil
[[file:plots/traectories/gradient_descent_1.png]]
#+CAPTION: Траектория метода на функции \(f_2\)
#+ATTR_LATEX: :scale 0.3 :options [H] :float nil
[[file:plots/traectories/gradient_descent_2.png]]
#+CAPTION: Траектория метода на функции \(f_3\)
#+ATTR_LATEX: :scale 0.3 :options [H] :float nil
[[file:plots/traectories/gradient_descent_3.png]]

При запуске на \(f_1\) методу потребовалось гораздо больше шагов
(\approx 800) дла нахождения минимума в отличии от функий \(f_2\)
(\approx 10 шагов) и \(f_1\) (\approx 40 шагов), так как число
обусловленности матрицы \(A\) функции \(f_1\) достаточно велико \(\mu
= 100\).
*** Метод наискорейшего спуска
#+CAPTION: Траектория метода на функции \(f_1\)
#+ATTR_LATEX: :scale 0.3 :options [H] :float nil
[[file:plots/traectories/steepest_descent_1.png]]
#+CAPTION: Траектория метода на функции \(f_3\)
#+ATTR_LATEX: :scale 0.3 :options [H] :float nil
[[file:plots/traectories/steepest_descent_3.png]]

Не смотря на высокое число обусловленности функции \(f_1\), метод
потребовалось 5 шагов для нахождение минимума. Но в то же время на
функции \(f_3\) потребовалось всего 2 шага.
*** Метод сопряженных градиентов
\-
#+CAPTION: Траектория метода на функции \(f_1\)
#+ATTR_LATEX: :scale 0.3 :options [H] :float nil
[[file:plots/traectories/conjugate_gradient_1.png]]
#+CAPTION: Траектория метода на функции \(f_2\)
#+ATTR_LATEX: :scale 0.3 :options [H] :float nil
[[file:plots/traectories/conjugate_gradient_2.png]]

В данном методе крайне редко удается добиться того, чтобы количество
итераций оказалось меньше размерности пространства
